MySQL Data Types
================

Numeric
-------

BIT(M=1), 1 <= M <= 64
    A bit field. Sometimes a synonym for TINYINT(1).

TINYINT(M) [UNSIGNED]
    A very small integer.
    Signed range is [-128, 127].
    Unsigned range is [0, 255].

BOOL / BOOLEAN
    Synonym for TINYINT(1). Boolean semantics.

SMALLINT(M) [UNSIGNED]
    A small integer.
    Signed range is [-32768, 32767].
    Unsigned range is [0, 65535].

MEDIUMINT(M) [UNSIGNED]
    Medium-sized integer.
    Signed range is [-8388608, 8388607].
    Unsigned range is [0, 16777215].

INT(M) / INTEGER(M) [UNSIGNED]
    Normal-sized integer.

BIGINT(M) [UNSIGNED]
    Large integer.

SERIAL
    An alias for BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE.

DECIMAL / DEC / NUMERIC / FIXED (M=10, D=0) [UNSIGNED], M <= 65, D <= 30
    Fixed-point number. M is the total number of digits, and D is the number of
    decimal digits after the point.

FLOAT(M, D) [UNSIGNED]
    Single-precision floating-point number. M is the toal number of digits, and
    D is the number of digits after the decimal point.

DOUBLE / DOUBLE PRECISION / REAL (M, D) [UNSIGNED]
    Double-precision floating-point number.

FLOAT(p) [UNSIGNED]
    Synonym for either FLOAT or DOUBLE depending on the precision p given.

Date and Time
-------------

DATE
    A date in the range [1000-01-01, 9999-12-31].
    String format is YYYY-MM-DD.

DATETIME
    A date and time.
    String format is YYYY-MM-DD HH:MM:SS.

TIMESTAMP
    Unix timestamp.
    The epoch is 1970-01-01 00:00:00 UTC.
    See also DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP.

TIME
    A time of day.
    String format is HH:MM:SS.

YEAR(2|4)
    A year in two or four digit format. In either case the range is
    [1901, 2155].

See also SEC_TO_TIME, TIME_TO_SEC, FROM_DAYS, TO_DAYS.

String
------

attribute CHARACTER SET / CHARSET
    The character set.
    e.g. binary, utf8, latin1

attribute COLLATE
    The collation.
    e.g. latin1_general_cs

attribute ASCII
    Shorthand for CHARACTER SET latin1.

attribute UNICODE
    Shorthand for CHARACTER SET ucs2.

attribute BINARY
    Shorthand for specifying binary collation. Causes characters to be compared
    by numeric value.

modifier NATIONAL
    The standard SQL way to prefix a string type which uses a custom character
    set, e.g. NATIONAL CHAR(255) CHARACTER SET utf8.

CHAR / CHARACTER (M=1), 0 <= M <= 255
    A fixed-length string of length M, right-padded with spaces which are
    automatically stripped when it is retrieved.
    CHAR(0) can be used as a dummy column whose values are not actually used.

NCHAR
    Synonym for NATIONAL CHAR

VARCHAR(M), 0 <= M <= 65,535
    A variable-length string with maximum size M. The effective maximum number
    of characters depends on the character set.
    The length limitation comes from the size of the length prefix used. Only
    one byte is used if the values require no more than 255 bytes; two bytes
    are used otherwise. Trailing spaces are preserved, unlike CHAR.

BINARY(M) / CHAR(M) BINARY
    Binary version of CHAR.

VARBINARY(M) / VARCHAR(M) BINARY
    Binary version of VARCHAR.

TINYBLOB
    A BLOB with a maximum length of 255 due to its 1-byte length prefix.

TINYTEXT
    TEXT with a maximum length of 255 due to its 1-byte length prefix.

BLOB(M) / TEXT(M) BINARY
    Binary data with a maximum length of 65,535.

TEXT(M), M <= 65,535
    Text column.

MEDIUMBLOB
    BLOB with a 3-byte length prefix.

MEDIUMTEXT
    TEXT with a 3-byte length prefix.

LONGBLOB
    BLOB with a 4-byte length prefix.

LONGTEXT
    TEXT with a 4-byte length prefix.

ENUM('value1', 'value2', ...)
    Enumerated type. Possible value are those listed plus NULL and the special
    error value ''. Represented internally as integers.

SET('value1', 'value2', ...)
    Set type which may contain zero or more of the listed value. Represented
    internally as integers. Maximum of 64 distinct members.

MySQL Mappings for Common SQL Data Types
----------------------------------------

BOOL / BOOLEAN       => TINYINT
CHARACTER VARYING(M) => VARCHAR(M)
FIXED / NUMERIC      => DECIMAL
FLOAT4               => FLOAT
FLOAT8               => DOUBLE
INT1                 => TINYINT
INT2                 => SMALLINT
INT3                 => MEDIUMINT
INT4                 => INT
INT8                 => BIGINT
LONG VARBINARY       => MEDIUMBLOB
LONG VARCHAR         => MEDIUMTEXT
LONG                 => MEDIUMTEXT
MIDDLEINT            => MEDIUMINT

SQLite Data Types
=================

Storage Classes
---------------

NULL

INTEGER
    Signed integer stored in 1, 2, 3, 4, 6, or 8 bytes depending on the
    magnitude. Always read into memory as an 8-byte signed integer.

REAL
    8-byte floating-point value.

TEXT
    A string. The encoding {UTF-8, UTF-16BE, UTF-16LE} used is database-wide.

BLOB
    Binary blob of data. What you put in is what you get out.

Data Types
----------

Boolean
    There is no boolean type; integers 0 and 1 are used instead.

Date and Time
    There are no date or time types. Instead they can be stored as TEXT in the
    format "YYYY-MM-DD HH:MM:SS.SSS", REAL in the form of Julian day numbers
    (the number of days since noon in Greenwich on Nov. 24, 4714 B.C. according
    to the proleptic Gregorian calendar), or INTEGER in the form of a Unix
    timestamp.

SQLite Affinity Mappings for Common SQL Data Types
--------------------------------------------------

*INT*              => INTEGER
*(CHAR|CLOB|TEXT)* => TEXT
*BLOB*             => NONE
*(REAL|FLOA|DOUB)* => REAL
[ else ]           => NUMERIC

Collations
----------

BINARY
    Uses memcmp(). This is the default.

NOCASE
    Case-insensitive version of BINARY. Applies to ASCII only.

RTRIM
    Ignores trailing whitespace.

[ custom ]
    Can be registered through sqlite_create_collation().

Phrame
======

Field Types
-----------

// MySQL:  BIT(width), 1 <= width <= 64
// SQLite: INT
// C++:    meta::int_fit_to_size<math::ceildiv(width, 8)>::type
bitfield<unsigned char width>()

    table.field("permissions", types::bitfield().width(10));

// MySQL:  BOOL
// SQLite: INT
// C++:    bool
boolean()

    table.field("admin", types::boolean());

// MySQL:  TINYINT(1)/SMALLINT(2)/MEDIUMINT(3)/INT(4)/BIGINT(8)
// SQLite: INT
// C++:    meta::int_fit_to_size<bytes, signed>::type
integer<unsigned char bytes, bool signed>()

    table.field("views", types::integer().size(6).signed_());

// MySQL:  DECIMAL/DEC/NUMERIC/FIXED(M, D), M <= 65, D <= 30
// SQLite: FLOAT + ROUND()
// C++:    float / pair<int, int> / Decimal ?
decimal<unsigned char digits_total, unsigned char digits_after>()

    table.field("price", types::decimal().before(9).after(2));
    table.field("price", types::dollars().before(9));

// MySQL:  FLOAT/DOUBLE/REAL(M, D)
// SQLite: REAL
// C++:    meta::float_fit_to_size<math::decimal_to_bytes>()
real<unsigned char digits_total = -1, unsigned char digits_after = -1>()

    table.field("ph", types::real().min(0.0).max(14.0));

// MySQL:  DATE
// SQLite: STRING + DATE()
// C++:    time_t / struct tm ?
date()

    table.field("birthday", types::date());
    table.field("birthday", types::date().day().str(":").month().str(":").year();

// MySQL:  TIME
// SQLite: STRING + TIME()
time()

    table.field("departure", types::time());

// MySQL:  DATETIME
// SQLite: STRING + DATETIME()
datetime()

    table.field("completed_at", types::datetime());

// MySQL:  TIMESTAMP
// SQLite: INTEGER + DATETIME(n, 'unixepoch')
// C++:    time_t
timestamp()

    table.field("access_time", types::timestamp());

// MySQL:  YEAR
// SQLite: STRING + STRFTIME('%Y')
year()

    table.field("published", types::year());

// MySQL:  CHAR/CHARACTER(N)
// SQLite: TEXT
fixedstring<unsigned char width>()

    // default encoding is ascii
    // default collation is binary/case-sensitive
    table.field("iso_code", types::fixedstring().length(3));

// MySQL:  VARCHAR(N)
// SQLite: TEXT
string<unsigned int maxlength>()

    // default encoding is utf8mb4 for MySQL
    // default collation is binary/case-sensitive
    table.field("name", types::string().max_length(50));
    table.field("title", types::string().max_length(100).case_insensitive());

// MySQL:  VARBINARY(N)
// SQLite: BLOB
bytestring<unsigned int maxlength>()

    table.field("raw_input", types::bytestring().max_length(255));

// MySQL:  TINYTEXT(1)/TEXT(2)/MEDIUMTEXT(3)/LONGTEXT(4)
// SQLite: TEXT
text<unsigned char prefix_size>()

    table.field("content", types::text().prefix_size(4));

// MySQL:  TINYBLOB(1)/BLOB(2)/MEDIUMBLOB(3)/LONGBLOB(4)
// SQLite: BLOB
data<unsigned char prefix_size>()

    table.field("gif_data", types::data().prefix_size(2));

Field Type Summary
------------------

Artificial Types
................

KEY [AUTOINCREMENT]

Numeric Types
.............

INTEGER(BYTES=4) [UNSIGNED]
REAL(PRECISION=double) [UNSIGNED]
BOOLEAN
DECIMAL(BEFORE, AFTER) [UNSIGNED]
BITFIELD(BITS)

Temporal Types
..............

TIMESTAMP
DATETIME(FORMAT=YYYY-MM-DD HH:MM:SS)
DATE(FORMAT=YYYY-MM-DD)
TIME(FORMAT=HH:MM:SS)
YEAR

String Types
............

STRING(MAXLENGTH) [CHARSET ENCODING=utf8] [COLLATE COLLATION=binary]
TEXT(PREFIXSIZE=4) [CHARSET ENCODING=utf8] [COLLATE COLLATION=binary]
FIXEDSTRING(LENGTH) [CHARSET ENCODING=ascii] [COLLATE COLLATION=binary]

Binary Types
............

BINARY(MAXLENGTH)
BLOB(PREFIXSIZE=4)
FIXEDBINARY(LENGTH)

MySQL Constraints
=================



